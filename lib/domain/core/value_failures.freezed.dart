// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target

part of 'value_failures.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more informations: https://github.com/rrousselGit/freezed#custom-getters-and-methods');

/// @nodoc
class _$ValueFailureTearOff {
  const _$ValueFailureTearOff();

  InvalidNftAnswer<T> invalidNftAnswer<T>({required T failedValue}) {
    return InvalidNftAnswer<T>(
      failedValue: failedValue,
    );
  }

  InvalidUrl<T> invalidUrl<T>({required T failedValue}) {
    return InvalidUrl<T>(
      failedValue: failedValue,
    );
  }

  InvalidNumberOfImages<T> invalidNumberOfImages<T>({required T failedValue}) {
    return InvalidNumberOfImages<T>(
      failedValue: failedValue,
    );
  }

  InvalidUserType<T> invalidUserType<T>({required T failedValue}) {
    return InvalidUserType<T>(
      failedValue: failedValue,
    );
  }

  InvalidName<T> invalidName<T>({required T failedValue}) {
    return InvalidName<T>(
      failedValue: failedValue,
    );
  }

  InvalidDateString<T> invalidDateString<T>({required T failedValue}) {
    return InvalidDateString<T>(
      failedValue: failedValue,
    );
  }

  InvalidCode<T> invalidCode<T>({required T failedValue}) {
    return InvalidCode<T>(
      failedValue: failedValue,
    );
  }

  InvalidEmail<T> invalidEmail<T>({required T failedValue}) {
    return InvalidEmail<T>(
      failedValue: failedValue,
    );
  }

  ShortPassword<T> shortPassword<T>({required T failedValue}) {
    return ShortPassword<T>(
      failedValue: failedValue,
    );
  }
}

/// @nodoc
const $ValueFailure = _$ValueFailureTearOff();

/// @nodoc
mixin _$ValueFailure<T> {
  T get failedValue => throw _privateConstructorUsedError;

  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(T failedValue) invalidNftAnswer,
    required TResult Function(T failedValue) invalidUrl,
    required TResult Function(T failedValue) invalidNumberOfImages,
    required TResult Function(T failedValue) invalidUserType,
    required TResult Function(T failedValue) invalidName,
    required TResult Function(T failedValue) invalidDateString,
    required TResult Function(T failedValue) invalidCode,
    required TResult Function(T failedValue) invalidEmail,
    required TResult Function(T failedValue) shortPassword,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function(T failedValue)? invalidNftAnswer,
    TResult Function(T failedValue)? invalidUrl,
    TResult Function(T failedValue)? invalidNumberOfImages,
    TResult Function(T failedValue)? invalidUserType,
    TResult Function(T failedValue)? invalidName,
    TResult Function(T failedValue)? invalidDateString,
    TResult Function(T failedValue)? invalidCode,
    TResult Function(T failedValue)? invalidEmail,
    TResult Function(T failedValue)? shortPassword,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(T failedValue)? invalidNftAnswer,
    TResult Function(T failedValue)? invalidUrl,
    TResult Function(T failedValue)? invalidNumberOfImages,
    TResult Function(T failedValue)? invalidUserType,
    TResult Function(T failedValue)? invalidName,
    TResult Function(T failedValue)? invalidDateString,
    TResult Function(T failedValue)? invalidCode,
    TResult Function(T failedValue)? invalidEmail,
    TResult Function(T failedValue)? shortPassword,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(InvalidNftAnswer<T> value) invalidNftAnswer,
    required TResult Function(InvalidUrl<T> value) invalidUrl,
    required TResult Function(InvalidNumberOfImages<T> value)
        invalidNumberOfImages,
    required TResult Function(InvalidUserType<T> value) invalidUserType,
    required TResult Function(InvalidName<T> value) invalidName,
    required TResult Function(InvalidDateString<T> value) invalidDateString,
    required TResult Function(InvalidCode<T> value) invalidCode,
    required TResult Function(InvalidEmail<T> value) invalidEmail,
    required TResult Function(ShortPassword<T> value) shortPassword,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(InvalidNftAnswer<T> value)? invalidNftAnswer,
    TResult Function(InvalidUrl<T> value)? invalidUrl,
    TResult Function(InvalidNumberOfImages<T> value)? invalidNumberOfImages,
    TResult Function(InvalidUserType<T> value)? invalidUserType,
    TResult Function(InvalidName<T> value)? invalidName,
    TResult Function(InvalidDateString<T> value)? invalidDateString,
    TResult Function(InvalidCode<T> value)? invalidCode,
    TResult Function(InvalidEmail<T> value)? invalidEmail,
    TResult Function(ShortPassword<T> value)? shortPassword,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(InvalidNftAnswer<T> value)? invalidNftAnswer,
    TResult Function(InvalidUrl<T> value)? invalidUrl,
    TResult Function(InvalidNumberOfImages<T> value)? invalidNumberOfImages,
    TResult Function(InvalidUserType<T> value)? invalidUserType,
    TResult Function(InvalidName<T> value)? invalidName,
    TResult Function(InvalidDateString<T> value)? invalidDateString,
    TResult Function(InvalidCode<T> value)? invalidCode,
    TResult Function(InvalidEmail<T> value)? invalidEmail,
    TResult Function(ShortPassword<T> value)? shortPassword,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;

  @JsonKey(ignore: true)
  $ValueFailureCopyWith<T, ValueFailure<T>> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $ValueFailureCopyWith<T, $Res> {
  factory $ValueFailureCopyWith(
          ValueFailure<T> value, $Res Function(ValueFailure<T>) then) =
      _$ValueFailureCopyWithImpl<T, $Res>;
  $Res call({T failedValue});
}

/// @nodoc
class _$ValueFailureCopyWithImpl<T, $Res>
    implements $ValueFailureCopyWith<T, $Res> {
  _$ValueFailureCopyWithImpl(this._value, this._then);

  final ValueFailure<T> _value;
  // ignore: unused_field
  final $Res Function(ValueFailure<T>) _then;

  @override
  $Res call({
    Object? failedValue = freezed,
  }) {
    return _then(_value.copyWith(
      failedValue: failedValue == freezed
          ? _value.failedValue
          : failedValue // ignore: cast_nullable_to_non_nullable
              as T,
    ));
  }
}

/// @nodoc
abstract class $InvalidNftAnswerCopyWith<T, $Res>
    implements $ValueFailureCopyWith<T, $Res> {
  factory $InvalidNftAnswerCopyWith(
          InvalidNftAnswer<T> value, $Res Function(InvalidNftAnswer<T>) then) =
      _$InvalidNftAnswerCopyWithImpl<T, $Res>;
  @override
  $Res call({T failedValue});
}

/// @nodoc
class _$InvalidNftAnswerCopyWithImpl<T, $Res>
    extends _$ValueFailureCopyWithImpl<T, $Res>
    implements $InvalidNftAnswerCopyWith<T, $Res> {
  _$InvalidNftAnswerCopyWithImpl(
      InvalidNftAnswer<T> _value, $Res Function(InvalidNftAnswer<T>) _then)
      : super(_value, (v) => _then(v as InvalidNftAnswer<T>));

  @override
  InvalidNftAnswer<T> get _value => super._value as InvalidNftAnswer<T>;

  @override
  $Res call({
    Object? failedValue = freezed,
  }) {
    return _then(InvalidNftAnswer<T>(
      failedValue: failedValue == freezed
          ? _value.failedValue
          : failedValue // ignore: cast_nullable_to_non_nullable
              as T,
    ));
  }
}

/// @nodoc

class _$InvalidNftAnswer<T> implements InvalidNftAnswer<T> {
  const _$InvalidNftAnswer({required this.failedValue});

  @override
  final T failedValue;

  @override
  String toString() {
    return 'ValueFailure<$T>.invalidNftAnswer(failedValue: $failedValue)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is InvalidNftAnswer<T> &&
            const DeepCollectionEquality()
                .equals(other.failedValue, failedValue));
  }

  @override
  int get hashCode => Object.hash(
      runtimeType, const DeepCollectionEquality().hash(failedValue));

  @JsonKey(ignore: true)
  @override
  $InvalidNftAnswerCopyWith<T, InvalidNftAnswer<T>> get copyWith =>
      _$InvalidNftAnswerCopyWithImpl<T, InvalidNftAnswer<T>>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(T failedValue) invalidNftAnswer,
    required TResult Function(T failedValue) invalidUrl,
    required TResult Function(T failedValue) invalidNumberOfImages,
    required TResult Function(T failedValue) invalidUserType,
    required TResult Function(T failedValue) invalidName,
    required TResult Function(T failedValue) invalidDateString,
    required TResult Function(T failedValue) invalidCode,
    required TResult Function(T failedValue) invalidEmail,
    required TResult Function(T failedValue) shortPassword,
  }) {
    return invalidNftAnswer(failedValue);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function(T failedValue)? invalidNftAnswer,
    TResult Function(T failedValue)? invalidUrl,
    TResult Function(T failedValue)? invalidNumberOfImages,
    TResult Function(T failedValue)? invalidUserType,
    TResult Function(T failedValue)? invalidName,
    TResult Function(T failedValue)? invalidDateString,
    TResult Function(T failedValue)? invalidCode,
    TResult Function(T failedValue)? invalidEmail,
    TResult Function(T failedValue)? shortPassword,
  }) {
    return invalidNftAnswer?.call(failedValue);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(T failedValue)? invalidNftAnswer,
    TResult Function(T failedValue)? invalidUrl,
    TResult Function(T failedValue)? invalidNumberOfImages,
    TResult Function(T failedValue)? invalidUserType,
    TResult Function(T failedValue)? invalidName,
    TResult Function(T failedValue)? invalidDateString,
    TResult Function(T failedValue)? invalidCode,
    TResult Function(T failedValue)? invalidEmail,
    TResult Function(T failedValue)? shortPassword,
    required TResult orElse(),
  }) {
    if (invalidNftAnswer != null) {
      return invalidNftAnswer(failedValue);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(InvalidNftAnswer<T> value) invalidNftAnswer,
    required TResult Function(InvalidUrl<T> value) invalidUrl,
    required TResult Function(InvalidNumberOfImages<T> value)
        invalidNumberOfImages,
    required TResult Function(InvalidUserType<T> value) invalidUserType,
    required TResult Function(InvalidName<T> value) invalidName,
    required TResult Function(InvalidDateString<T> value) invalidDateString,
    required TResult Function(InvalidCode<T> value) invalidCode,
    required TResult Function(InvalidEmail<T> value) invalidEmail,
    required TResult Function(ShortPassword<T> value) shortPassword,
  }) {
    return invalidNftAnswer(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(InvalidNftAnswer<T> value)? invalidNftAnswer,
    TResult Function(InvalidUrl<T> value)? invalidUrl,
    TResult Function(InvalidNumberOfImages<T> value)? invalidNumberOfImages,
    TResult Function(InvalidUserType<T> value)? invalidUserType,
    TResult Function(InvalidName<T> value)? invalidName,
    TResult Function(InvalidDateString<T> value)? invalidDateString,
    TResult Function(InvalidCode<T> value)? invalidCode,
    TResult Function(InvalidEmail<T> value)? invalidEmail,
    TResult Function(ShortPassword<T> value)? shortPassword,
  }) {
    return invalidNftAnswer?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(InvalidNftAnswer<T> value)? invalidNftAnswer,
    TResult Function(InvalidUrl<T> value)? invalidUrl,
    TResult Function(InvalidNumberOfImages<T> value)? invalidNumberOfImages,
    TResult Function(InvalidUserType<T> value)? invalidUserType,
    TResult Function(InvalidName<T> value)? invalidName,
    TResult Function(InvalidDateString<T> value)? invalidDateString,
    TResult Function(InvalidCode<T> value)? invalidCode,
    TResult Function(InvalidEmail<T> value)? invalidEmail,
    TResult Function(ShortPassword<T> value)? shortPassword,
    required TResult orElse(),
  }) {
    if (invalidNftAnswer != null) {
      return invalidNftAnswer(this);
    }
    return orElse();
  }
}

abstract class InvalidNftAnswer<T> implements ValueFailure<T> {
  const factory InvalidNftAnswer({required T failedValue}) =
      _$InvalidNftAnswer<T>;

  @override
  T get failedValue;
  @override
  @JsonKey(ignore: true)
  $InvalidNftAnswerCopyWith<T, InvalidNftAnswer<T>> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $InvalidUrlCopyWith<T, $Res>
    implements $ValueFailureCopyWith<T, $Res> {
  factory $InvalidUrlCopyWith(
          InvalidUrl<T> value, $Res Function(InvalidUrl<T>) then) =
      _$InvalidUrlCopyWithImpl<T, $Res>;
  @override
  $Res call({T failedValue});
}

/// @nodoc
class _$InvalidUrlCopyWithImpl<T, $Res>
    extends _$ValueFailureCopyWithImpl<T, $Res>
    implements $InvalidUrlCopyWith<T, $Res> {
  _$InvalidUrlCopyWithImpl(
      InvalidUrl<T> _value, $Res Function(InvalidUrl<T>) _then)
      : super(_value, (v) => _then(v as InvalidUrl<T>));

  @override
  InvalidUrl<T> get _value => super._value as InvalidUrl<T>;

  @override
  $Res call({
    Object? failedValue = freezed,
  }) {
    return _then(InvalidUrl<T>(
      failedValue: failedValue == freezed
          ? _value.failedValue
          : failedValue // ignore: cast_nullable_to_non_nullable
              as T,
    ));
  }
}

/// @nodoc

class _$InvalidUrl<T> implements InvalidUrl<T> {
  const _$InvalidUrl({required this.failedValue});

  @override
  final T failedValue;

  @override
  String toString() {
    return 'ValueFailure<$T>.invalidUrl(failedValue: $failedValue)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is InvalidUrl<T> &&
            const DeepCollectionEquality()
                .equals(other.failedValue, failedValue));
  }

  @override
  int get hashCode => Object.hash(
      runtimeType, const DeepCollectionEquality().hash(failedValue));

  @JsonKey(ignore: true)
  @override
  $InvalidUrlCopyWith<T, InvalidUrl<T>> get copyWith =>
      _$InvalidUrlCopyWithImpl<T, InvalidUrl<T>>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(T failedValue) invalidNftAnswer,
    required TResult Function(T failedValue) invalidUrl,
    required TResult Function(T failedValue) invalidNumberOfImages,
    required TResult Function(T failedValue) invalidUserType,
    required TResult Function(T failedValue) invalidName,
    required TResult Function(T failedValue) invalidDateString,
    required TResult Function(T failedValue) invalidCode,
    required TResult Function(T failedValue) invalidEmail,
    required TResult Function(T failedValue) shortPassword,
  }) {
    return invalidUrl(failedValue);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function(T failedValue)? invalidNftAnswer,
    TResult Function(T failedValue)? invalidUrl,
    TResult Function(T failedValue)? invalidNumberOfImages,
    TResult Function(T failedValue)? invalidUserType,
    TResult Function(T failedValue)? invalidName,
    TResult Function(T failedValue)? invalidDateString,
    TResult Function(T failedValue)? invalidCode,
    TResult Function(T failedValue)? invalidEmail,
    TResult Function(T failedValue)? shortPassword,
  }) {
    return invalidUrl?.call(failedValue);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(T failedValue)? invalidNftAnswer,
    TResult Function(T failedValue)? invalidUrl,
    TResult Function(T failedValue)? invalidNumberOfImages,
    TResult Function(T failedValue)? invalidUserType,
    TResult Function(T failedValue)? invalidName,
    TResult Function(T failedValue)? invalidDateString,
    TResult Function(T failedValue)? invalidCode,
    TResult Function(T failedValue)? invalidEmail,
    TResult Function(T failedValue)? shortPassword,
    required TResult orElse(),
  }) {
    if (invalidUrl != null) {
      return invalidUrl(failedValue);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(InvalidNftAnswer<T> value) invalidNftAnswer,
    required TResult Function(InvalidUrl<T> value) invalidUrl,
    required TResult Function(InvalidNumberOfImages<T> value)
        invalidNumberOfImages,
    required TResult Function(InvalidUserType<T> value) invalidUserType,
    required TResult Function(InvalidName<T> value) invalidName,
    required TResult Function(InvalidDateString<T> value) invalidDateString,
    required TResult Function(InvalidCode<T> value) invalidCode,
    required TResult Function(InvalidEmail<T> value) invalidEmail,
    required TResult Function(ShortPassword<T> value) shortPassword,
  }) {
    return invalidUrl(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(InvalidNftAnswer<T> value)? invalidNftAnswer,
    TResult Function(InvalidUrl<T> value)? invalidUrl,
    TResult Function(InvalidNumberOfImages<T> value)? invalidNumberOfImages,
    TResult Function(InvalidUserType<T> value)? invalidUserType,
    TResult Function(InvalidName<T> value)? invalidName,
    TResult Function(InvalidDateString<T> value)? invalidDateString,
    TResult Function(InvalidCode<T> value)? invalidCode,
    TResult Function(InvalidEmail<T> value)? invalidEmail,
    TResult Function(ShortPassword<T> value)? shortPassword,
  }) {
    return invalidUrl?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(InvalidNftAnswer<T> value)? invalidNftAnswer,
    TResult Function(InvalidUrl<T> value)? invalidUrl,
    TResult Function(InvalidNumberOfImages<T> value)? invalidNumberOfImages,
    TResult Function(InvalidUserType<T> value)? invalidUserType,
    TResult Function(InvalidName<T> value)? invalidName,
    TResult Function(InvalidDateString<T> value)? invalidDateString,
    TResult Function(InvalidCode<T> value)? invalidCode,
    TResult Function(InvalidEmail<T> value)? invalidEmail,
    TResult Function(ShortPassword<T> value)? shortPassword,
    required TResult orElse(),
  }) {
    if (invalidUrl != null) {
      return invalidUrl(this);
    }
    return orElse();
  }
}

abstract class InvalidUrl<T> implements ValueFailure<T> {
  const factory InvalidUrl({required T failedValue}) = _$InvalidUrl<T>;

  @override
  T get failedValue;
  @override
  @JsonKey(ignore: true)
  $InvalidUrlCopyWith<T, InvalidUrl<T>> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $InvalidNumberOfImagesCopyWith<T, $Res>
    implements $ValueFailureCopyWith<T, $Res> {
  factory $InvalidNumberOfImagesCopyWith(InvalidNumberOfImages<T> value,
          $Res Function(InvalidNumberOfImages<T>) then) =
      _$InvalidNumberOfImagesCopyWithImpl<T, $Res>;
  @override
  $Res call({T failedValue});
}

/// @nodoc
class _$InvalidNumberOfImagesCopyWithImpl<T, $Res>
    extends _$ValueFailureCopyWithImpl<T, $Res>
    implements $InvalidNumberOfImagesCopyWith<T, $Res> {
  _$InvalidNumberOfImagesCopyWithImpl(InvalidNumberOfImages<T> _value,
      $Res Function(InvalidNumberOfImages<T>) _then)
      : super(_value, (v) => _then(v as InvalidNumberOfImages<T>));

  @override
  InvalidNumberOfImages<T> get _value =>
      super._value as InvalidNumberOfImages<T>;

  @override
  $Res call({
    Object? failedValue = freezed,
  }) {
    return _then(InvalidNumberOfImages<T>(
      failedValue: failedValue == freezed
          ? _value.failedValue
          : failedValue // ignore: cast_nullable_to_non_nullable
              as T,
    ));
  }
}

/// @nodoc

class _$InvalidNumberOfImages<T> implements InvalidNumberOfImages<T> {
  const _$InvalidNumberOfImages({required this.failedValue});

  @override
  final T failedValue;

  @override
  String toString() {
    return 'ValueFailure<$T>.invalidNumberOfImages(failedValue: $failedValue)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is InvalidNumberOfImages<T> &&
            const DeepCollectionEquality()
                .equals(other.failedValue, failedValue));
  }

  @override
  int get hashCode => Object.hash(
      runtimeType, const DeepCollectionEquality().hash(failedValue));

  @JsonKey(ignore: true)
  @override
  $InvalidNumberOfImagesCopyWith<T, InvalidNumberOfImages<T>> get copyWith =>
      _$InvalidNumberOfImagesCopyWithImpl<T, InvalidNumberOfImages<T>>(
          this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(T failedValue) invalidNftAnswer,
    required TResult Function(T failedValue) invalidUrl,
    required TResult Function(T failedValue) invalidNumberOfImages,
    required TResult Function(T failedValue) invalidUserType,
    required TResult Function(T failedValue) invalidName,
    required TResult Function(T failedValue) invalidDateString,
    required TResult Function(T failedValue) invalidCode,
    required TResult Function(T failedValue) invalidEmail,
    required TResult Function(T failedValue) shortPassword,
  }) {
    return invalidNumberOfImages(failedValue);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function(T failedValue)? invalidNftAnswer,
    TResult Function(T failedValue)? invalidUrl,
    TResult Function(T failedValue)? invalidNumberOfImages,
    TResult Function(T failedValue)? invalidUserType,
    TResult Function(T failedValue)? invalidName,
    TResult Function(T failedValue)? invalidDateString,
    TResult Function(T failedValue)? invalidCode,
    TResult Function(T failedValue)? invalidEmail,
    TResult Function(T failedValue)? shortPassword,
  }) {
    return invalidNumberOfImages?.call(failedValue);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(T failedValue)? invalidNftAnswer,
    TResult Function(T failedValue)? invalidUrl,
    TResult Function(T failedValue)? invalidNumberOfImages,
    TResult Function(T failedValue)? invalidUserType,
    TResult Function(T failedValue)? invalidName,
    TResult Function(T failedValue)? invalidDateString,
    TResult Function(T failedValue)? invalidCode,
    TResult Function(T failedValue)? invalidEmail,
    TResult Function(T failedValue)? shortPassword,
    required TResult orElse(),
  }) {
    if (invalidNumberOfImages != null) {
      return invalidNumberOfImages(failedValue);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(InvalidNftAnswer<T> value) invalidNftAnswer,
    required TResult Function(InvalidUrl<T> value) invalidUrl,
    required TResult Function(InvalidNumberOfImages<T> value)
        invalidNumberOfImages,
    required TResult Function(InvalidUserType<T> value) invalidUserType,
    required TResult Function(InvalidName<T> value) invalidName,
    required TResult Function(InvalidDateString<T> value) invalidDateString,
    required TResult Function(InvalidCode<T> value) invalidCode,
    required TResult Function(InvalidEmail<T> value) invalidEmail,
    required TResult Function(ShortPassword<T> value) shortPassword,
  }) {
    return invalidNumberOfImages(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(InvalidNftAnswer<T> value)? invalidNftAnswer,
    TResult Function(InvalidUrl<T> value)? invalidUrl,
    TResult Function(InvalidNumberOfImages<T> value)? invalidNumberOfImages,
    TResult Function(InvalidUserType<T> value)? invalidUserType,
    TResult Function(InvalidName<T> value)? invalidName,
    TResult Function(InvalidDateString<T> value)? invalidDateString,
    TResult Function(InvalidCode<T> value)? invalidCode,
    TResult Function(InvalidEmail<T> value)? invalidEmail,
    TResult Function(ShortPassword<T> value)? shortPassword,
  }) {
    return invalidNumberOfImages?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(InvalidNftAnswer<T> value)? invalidNftAnswer,
    TResult Function(InvalidUrl<T> value)? invalidUrl,
    TResult Function(InvalidNumberOfImages<T> value)? invalidNumberOfImages,
    TResult Function(InvalidUserType<T> value)? invalidUserType,
    TResult Function(InvalidName<T> value)? invalidName,
    TResult Function(InvalidDateString<T> value)? invalidDateString,
    TResult Function(InvalidCode<T> value)? invalidCode,
    TResult Function(InvalidEmail<T> value)? invalidEmail,
    TResult Function(ShortPassword<T> value)? shortPassword,
    required TResult orElse(),
  }) {
    if (invalidNumberOfImages != null) {
      return invalidNumberOfImages(this);
    }
    return orElse();
  }
}

abstract class InvalidNumberOfImages<T> implements ValueFailure<T> {
  const factory InvalidNumberOfImages({required T failedValue}) =
      _$InvalidNumberOfImages<T>;

  @override
  T get failedValue;
  @override
  @JsonKey(ignore: true)
  $InvalidNumberOfImagesCopyWith<T, InvalidNumberOfImages<T>> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $InvalidUserTypeCopyWith<T, $Res>
    implements $ValueFailureCopyWith<T, $Res> {
  factory $InvalidUserTypeCopyWith(
          InvalidUserType<T> value, $Res Function(InvalidUserType<T>) then) =
      _$InvalidUserTypeCopyWithImpl<T, $Res>;
  @override
  $Res call({T failedValue});
}

/// @nodoc
class _$InvalidUserTypeCopyWithImpl<T, $Res>
    extends _$ValueFailureCopyWithImpl<T, $Res>
    implements $InvalidUserTypeCopyWith<T, $Res> {
  _$InvalidUserTypeCopyWithImpl(
      InvalidUserType<T> _value, $Res Function(InvalidUserType<T>) _then)
      : super(_value, (v) => _then(v as InvalidUserType<T>));

  @override
  InvalidUserType<T> get _value => super._value as InvalidUserType<T>;

  @override
  $Res call({
    Object? failedValue = freezed,
  }) {
    return _then(InvalidUserType<T>(
      failedValue: failedValue == freezed
          ? _value.failedValue
          : failedValue // ignore: cast_nullable_to_non_nullable
              as T,
    ));
  }
}

/// @nodoc

class _$InvalidUserType<T> implements InvalidUserType<T> {
  const _$InvalidUserType({required this.failedValue});

  @override
  final T failedValue;

  @override
  String toString() {
    return 'ValueFailure<$T>.invalidUserType(failedValue: $failedValue)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is InvalidUserType<T> &&
            const DeepCollectionEquality()
                .equals(other.failedValue, failedValue));
  }

  @override
  int get hashCode => Object.hash(
      runtimeType, const DeepCollectionEquality().hash(failedValue));

  @JsonKey(ignore: true)
  @override
  $InvalidUserTypeCopyWith<T, InvalidUserType<T>> get copyWith =>
      _$InvalidUserTypeCopyWithImpl<T, InvalidUserType<T>>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(T failedValue) invalidNftAnswer,
    required TResult Function(T failedValue) invalidUrl,
    required TResult Function(T failedValue) invalidNumberOfImages,
    required TResult Function(T failedValue) invalidUserType,
    required TResult Function(T failedValue) invalidName,
    required TResult Function(T failedValue) invalidDateString,
    required TResult Function(T failedValue) invalidCode,
    required TResult Function(T failedValue) invalidEmail,
    required TResult Function(T failedValue) shortPassword,
  }) {
    return invalidUserType(failedValue);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function(T failedValue)? invalidNftAnswer,
    TResult Function(T failedValue)? invalidUrl,
    TResult Function(T failedValue)? invalidNumberOfImages,
    TResult Function(T failedValue)? invalidUserType,
    TResult Function(T failedValue)? invalidName,
    TResult Function(T failedValue)? invalidDateString,
    TResult Function(T failedValue)? invalidCode,
    TResult Function(T failedValue)? invalidEmail,
    TResult Function(T failedValue)? shortPassword,
  }) {
    return invalidUserType?.call(failedValue);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(T failedValue)? invalidNftAnswer,
    TResult Function(T failedValue)? invalidUrl,
    TResult Function(T failedValue)? invalidNumberOfImages,
    TResult Function(T failedValue)? invalidUserType,
    TResult Function(T failedValue)? invalidName,
    TResult Function(T failedValue)? invalidDateString,
    TResult Function(T failedValue)? invalidCode,
    TResult Function(T failedValue)? invalidEmail,
    TResult Function(T failedValue)? shortPassword,
    required TResult orElse(),
  }) {
    if (invalidUserType != null) {
      return invalidUserType(failedValue);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(InvalidNftAnswer<T> value) invalidNftAnswer,
    required TResult Function(InvalidUrl<T> value) invalidUrl,
    required TResult Function(InvalidNumberOfImages<T> value)
        invalidNumberOfImages,
    required TResult Function(InvalidUserType<T> value) invalidUserType,
    required TResult Function(InvalidName<T> value) invalidName,
    required TResult Function(InvalidDateString<T> value) invalidDateString,
    required TResult Function(InvalidCode<T> value) invalidCode,
    required TResult Function(InvalidEmail<T> value) invalidEmail,
    required TResult Function(ShortPassword<T> value) shortPassword,
  }) {
    return invalidUserType(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(InvalidNftAnswer<T> value)? invalidNftAnswer,
    TResult Function(InvalidUrl<T> value)? invalidUrl,
    TResult Function(InvalidNumberOfImages<T> value)? invalidNumberOfImages,
    TResult Function(InvalidUserType<T> value)? invalidUserType,
    TResult Function(InvalidName<T> value)? invalidName,
    TResult Function(InvalidDateString<T> value)? invalidDateString,
    TResult Function(InvalidCode<T> value)? invalidCode,
    TResult Function(InvalidEmail<T> value)? invalidEmail,
    TResult Function(ShortPassword<T> value)? shortPassword,
  }) {
    return invalidUserType?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(InvalidNftAnswer<T> value)? invalidNftAnswer,
    TResult Function(InvalidUrl<T> value)? invalidUrl,
    TResult Function(InvalidNumberOfImages<T> value)? invalidNumberOfImages,
    TResult Function(InvalidUserType<T> value)? invalidUserType,
    TResult Function(InvalidName<T> value)? invalidName,
    TResult Function(InvalidDateString<T> value)? invalidDateString,
    TResult Function(InvalidCode<T> value)? invalidCode,
    TResult Function(InvalidEmail<T> value)? invalidEmail,
    TResult Function(ShortPassword<T> value)? shortPassword,
    required TResult orElse(),
  }) {
    if (invalidUserType != null) {
      return invalidUserType(this);
    }
    return orElse();
  }
}

abstract class InvalidUserType<T> implements ValueFailure<T> {
  const factory InvalidUserType({required T failedValue}) =
      _$InvalidUserType<T>;

  @override
  T get failedValue;
  @override
  @JsonKey(ignore: true)
  $InvalidUserTypeCopyWith<T, InvalidUserType<T>> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $InvalidNameCopyWith<T, $Res>
    implements $ValueFailureCopyWith<T, $Res> {
  factory $InvalidNameCopyWith(
          InvalidName<T> value, $Res Function(InvalidName<T>) then) =
      _$InvalidNameCopyWithImpl<T, $Res>;
  @override
  $Res call({T failedValue});
}

/// @nodoc
class _$InvalidNameCopyWithImpl<T, $Res>
    extends _$ValueFailureCopyWithImpl<T, $Res>
    implements $InvalidNameCopyWith<T, $Res> {
  _$InvalidNameCopyWithImpl(
      InvalidName<T> _value, $Res Function(InvalidName<T>) _then)
      : super(_value, (v) => _then(v as InvalidName<T>));

  @override
  InvalidName<T> get _value => super._value as InvalidName<T>;

  @override
  $Res call({
    Object? failedValue = freezed,
  }) {
    return _then(InvalidName<T>(
      failedValue: failedValue == freezed
          ? _value.failedValue
          : failedValue // ignore: cast_nullable_to_non_nullable
              as T,
    ));
  }
}

/// @nodoc

class _$InvalidName<T> implements InvalidName<T> {
  const _$InvalidName({required this.failedValue});

  @override
  final T failedValue;

  @override
  String toString() {
    return 'ValueFailure<$T>.invalidName(failedValue: $failedValue)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is InvalidName<T> &&
            const DeepCollectionEquality()
                .equals(other.failedValue, failedValue));
  }

  @override
  int get hashCode => Object.hash(
      runtimeType, const DeepCollectionEquality().hash(failedValue));

  @JsonKey(ignore: true)
  @override
  $InvalidNameCopyWith<T, InvalidName<T>> get copyWith =>
      _$InvalidNameCopyWithImpl<T, InvalidName<T>>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(T failedValue) invalidNftAnswer,
    required TResult Function(T failedValue) invalidUrl,
    required TResult Function(T failedValue) invalidNumberOfImages,
    required TResult Function(T failedValue) invalidUserType,
    required TResult Function(T failedValue) invalidName,
    required TResult Function(T failedValue) invalidDateString,
    required TResult Function(T failedValue) invalidCode,
    required TResult Function(T failedValue) invalidEmail,
    required TResult Function(T failedValue) shortPassword,
  }) {
    return invalidName(failedValue);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function(T failedValue)? invalidNftAnswer,
    TResult Function(T failedValue)? invalidUrl,
    TResult Function(T failedValue)? invalidNumberOfImages,
    TResult Function(T failedValue)? invalidUserType,
    TResult Function(T failedValue)? invalidName,
    TResult Function(T failedValue)? invalidDateString,
    TResult Function(T failedValue)? invalidCode,
    TResult Function(T failedValue)? invalidEmail,
    TResult Function(T failedValue)? shortPassword,
  }) {
    return invalidName?.call(failedValue);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(T failedValue)? invalidNftAnswer,
    TResult Function(T failedValue)? invalidUrl,
    TResult Function(T failedValue)? invalidNumberOfImages,
    TResult Function(T failedValue)? invalidUserType,
    TResult Function(T failedValue)? invalidName,
    TResult Function(T failedValue)? invalidDateString,
    TResult Function(T failedValue)? invalidCode,
    TResult Function(T failedValue)? invalidEmail,
    TResult Function(T failedValue)? shortPassword,
    required TResult orElse(),
  }) {
    if (invalidName != null) {
      return invalidName(failedValue);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(InvalidNftAnswer<T> value) invalidNftAnswer,
    required TResult Function(InvalidUrl<T> value) invalidUrl,
    required TResult Function(InvalidNumberOfImages<T> value)
        invalidNumberOfImages,
    required TResult Function(InvalidUserType<T> value) invalidUserType,
    required TResult Function(InvalidName<T> value) invalidName,
    required TResult Function(InvalidDateString<T> value) invalidDateString,
    required TResult Function(InvalidCode<T> value) invalidCode,
    required TResult Function(InvalidEmail<T> value) invalidEmail,
    required TResult Function(ShortPassword<T> value) shortPassword,
  }) {
    return invalidName(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(InvalidNftAnswer<T> value)? invalidNftAnswer,
    TResult Function(InvalidUrl<T> value)? invalidUrl,
    TResult Function(InvalidNumberOfImages<T> value)? invalidNumberOfImages,
    TResult Function(InvalidUserType<T> value)? invalidUserType,
    TResult Function(InvalidName<T> value)? invalidName,
    TResult Function(InvalidDateString<T> value)? invalidDateString,
    TResult Function(InvalidCode<T> value)? invalidCode,
    TResult Function(InvalidEmail<T> value)? invalidEmail,
    TResult Function(ShortPassword<T> value)? shortPassword,
  }) {
    return invalidName?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(InvalidNftAnswer<T> value)? invalidNftAnswer,
    TResult Function(InvalidUrl<T> value)? invalidUrl,
    TResult Function(InvalidNumberOfImages<T> value)? invalidNumberOfImages,
    TResult Function(InvalidUserType<T> value)? invalidUserType,
    TResult Function(InvalidName<T> value)? invalidName,
    TResult Function(InvalidDateString<T> value)? invalidDateString,
    TResult Function(InvalidCode<T> value)? invalidCode,
    TResult Function(InvalidEmail<T> value)? invalidEmail,
    TResult Function(ShortPassword<T> value)? shortPassword,
    required TResult orElse(),
  }) {
    if (invalidName != null) {
      return invalidName(this);
    }
    return orElse();
  }
}

abstract class InvalidName<T> implements ValueFailure<T> {
  const factory InvalidName({required T failedValue}) = _$InvalidName<T>;

  @override
  T get failedValue;
  @override
  @JsonKey(ignore: true)
  $InvalidNameCopyWith<T, InvalidName<T>> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $InvalidDateStringCopyWith<T, $Res>
    implements $ValueFailureCopyWith<T, $Res> {
  factory $InvalidDateStringCopyWith(InvalidDateString<T> value,
          $Res Function(InvalidDateString<T>) then) =
      _$InvalidDateStringCopyWithImpl<T, $Res>;
  @override
  $Res call({T failedValue});
}

/// @nodoc
class _$InvalidDateStringCopyWithImpl<T, $Res>
    extends _$ValueFailureCopyWithImpl<T, $Res>
    implements $InvalidDateStringCopyWith<T, $Res> {
  _$InvalidDateStringCopyWithImpl(
      InvalidDateString<T> _value, $Res Function(InvalidDateString<T>) _then)
      : super(_value, (v) => _then(v as InvalidDateString<T>));

  @override
  InvalidDateString<T> get _value => super._value as InvalidDateString<T>;

  @override
  $Res call({
    Object? failedValue = freezed,
  }) {
    return _then(InvalidDateString<T>(
      failedValue: failedValue == freezed
          ? _value.failedValue
          : failedValue // ignore: cast_nullable_to_non_nullable
              as T,
    ));
  }
}

/// @nodoc

class _$InvalidDateString<T> implements InvalidDateString<T> {
  const _$InvalidDateString({required this.failedValue});

  @override
  final T failedValue;

  @override
  String toString() {
    return 'ValueFailure<$T>.invalidDateString(failedValue: $failedValue)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is InvalidDateString<T> &&
            const DeepCollectionEquality()
                .equals(other.failedValue, failedValue));
  }

  @override
  int get hashCode => Object.hash(
      runtimeType, const DeepCollectionEquality().hash(failedValue));

  @JsonKey(ignore: true)
  @override
  $InvalidDateStringCopyWith<T, InvalidDateString<T>> get copyWith =>
      _$InvalidDateStringCopyWithImpl<T, InvalidDateString<T>>(
          this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(T failedValue) invalidNftAnswer,
    required TResult Function(T failedValue) invalidUrl,
    required TResult Function(T failedValue) invalidNumberOfImages,
    required TResult Function(T failedValue) invalidUserType,
    required TResult Function(T failedValue) invalidName,
    required TResult Function(T failedValue) invalidDateString,
    required TResult Function(T failedValue) invalidCode,
    required TResult Function(T failedValue) invalidEmail,
    required TResult Function(T failedValue) shortPassword,
  }) {
    return invalidDateString(failedValue);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function(T failedValue)? invalidNftAnswer,
    TResult Function(T failedValue)? invalidUrl,
    TResult Function(T failedValue)? invalidNumberOfImages,
    TResult Function(T failedValue)? invalidUserType,
    TResult Function(T failedValue)? invalidName,
    TResult Function(T failedValue)? invalidDateString,
    TResult Function(T failedValue)? invalidCode,
    TResult Function(T failedValue)? invalidEmail,
    TResult Function(T failedValue)? shortPassword,
  }) {
    return invalidDateString?.call(failedValue);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(T failedValue)? invalidNftAnswer,
    TResult Function(T failedValue)? invalidUrl,
    TResult Function(T failedValue)? invalidNumberOfImages,
    TResult Function(T failedValue)? invalidUserType,
    TResult Function(T failedValue)? invalidName,
    TResult Function(T failedValue)? invalidDateString,
    TResult Function(T failedValue)? invalidCode,
    TResult Function(T failedValue)? invalidEmail,
    TResult Function(T failedValue)? shortPassword,
    required TResult orElse(),
  }) {
    if (invalidDateString != null) {
      return invalidDateString(failedValue);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(InvalidNftAnswer<T> value) invalidNftAnswer,
    required TResult Function(InvalidUrl<T> value) invalidUrl,
    required TResult Function(InvalidNumberOfImages<T> value)
        invalidNumberOfImages,
    required TResult Function(InvalidUserType<T> value) invalidUserType,
    required TResult Function(InvalidName<T> value) invalidName,
    required TResult Function(InvalidDateString<T> value) invalidDateString,
    required TResult Function(InvalidCode<T> value) invalidCode,
    required TResult Function(InvalidEmail<T> value) invalidEmail,
    required TResult Function(ShortPassword<T> value) shortPassword,
  }) {
    return invalidDateString(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(InvalidNftAnswer<T> value)? invalidNftAnswer,
    TResult Function(InvalidUrl<T> value)? invalidUrl,
    TResult Function(InvalidNumberOfImages<T> value)? invalidNumberOfImages,
    TResult Function(InvalidUserType<T> value)? invalidUserType,
    TResult Function(InvalidName<T> value)? invalidName,
    TResult Function(InvalidDateString<T> value)? invalidDateString,
    TResult Function(InvalidCode<T> value)? invalidCode,
    TResult Function(InvalidEmail<T> value)? invalidEmail,
    TResult Function(ShortPassword<T> value)? shortPassword,
  }) {
    return invalidDateString?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(InvalidNftAnswer<T> value)? invalidNftAnswer,
    TResult Function(InvalidUrl<T> value)? invalidUrl,
    TResult Function(InvalidNumberOfImages<T> value)? invalidNumberOfImages,
    TResult Function(InvalidUserType<T> value)? invalidUserType,
    TResult Function(InvalidName<T> value)? invalidName,
    TResult Function(InvalidDateString<T> value)? invalidDateString,
    TResult Function(InvalidCode<T> value)? invalidCode,
    TResult Function(InvalidEmail<T> value)? invalidEmail,
    TResult Function(ShortPassword<T> value)? shortPassword,
    required TResult orElse(),
  }) {
    if (invalidDateString != null) {
      return invalidDateString(this);
    }
    return orElse();
  }
}

abstract class InvalidDateString<T> implements ValueFailure<T> {
  const factory InvalidDateString({required T failedValue}) =
      _$InvalidDateString<T>;

  @override
  T get failedValue;
  @override
  @JsonKey(ignore: true)
  $InvalidDateStringCopyWith<T, InvalidDateString<T>> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $InvalidCodeCopyWith<T, $Res>
    implements $ValueFailureCopyWith<T, $Res> {
  factory $InvalidCodeCopyWith(
          InvalidCode<T> value, $Res Function(InvalidCode<T>) then) =
      _$InvalidCodeCopyWithImpl<T, $Res>;
  @override
  $Res call({T failedValue});
}

/// @nodoc
class _$InvalidCodeCopyWithImpl<T, $Res>
    extends _$ValueFailureCopyWithImpl<T, $Res>
    implements $InvalidCodeCopyWith<T, $Res> {
  _$InvalidCodeCopyWithImpl(
      InvalidCode<T> _value, $Res Function(InvalidCode<T>) _then)
      : super(_value, (v) => _then(v as InvalidCode<T>));

  @override
  InvalidCode<T> get _value => super._value as InvalidCode<T>;

  @override
  $Res call({
    Object? failedValue = freezed,
  }) {
    return _then(InvalidCode<T>(
      failedValue: failedValue == freezed
          ? _value.failedValue
          : failedValue // ignore: cast_nullable_to_non_nullable
              as T,
    ));
  }
}

/// @nodoc

class _$InvalidCode<T> implements InvalidCode<T> {
  const _$InvalidCode({required this.failedValue});

  @override
  final T failedValue;

  @override
  String toString() {
    return 'ValueFailure<$T>.invalidCode(failedValue: $failedValue)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is InvalidCode<T> &&
            const DeepCollectionEquality()
                .equals(other.failedValue, failedValue));
  }

  @override
  int get hashCode => Object.hash(
      runtimeType, const DeepCollectionEquality().hash(failedValue));

  @JsonKey(ignore: true)
  @override
  $InvalidCodeCopyWith<T, InvalidCode<T>> get copyWith =>
      _$InvalidCodeCopyWithImpl<T, InvalidCode<T>>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(T failedValue) invalidNftAnswer,
    required TResult Function(T failedValue) invalidUrl,
    required TResult Function(T failedValue) invalidNumberOfImages,
    required TResult Function(T failedValue) invalidUserType,
    required TResult Function(T failedValue) invalidName,
    required TResult Function(T failedValue) invalidDateString,
    required TResult Function(T failedValue) invalidCode,
    required TResult Function(T failedValue) invalidEmail,
    required TResult Function(T failedValue) shortPassword,
  }) {
    return invalidCode(failedValue);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function(T failedValue)? invalidNftAnswer,
    TResult Function(T failedValue)? invalidUrl,
    TResult Function(T failedValue)? invalidNumberOfImages,
    TResult Function(T failedValue)? invalidUserType,
    TResult Function(T failedValue)? invalidName,
    TResult Function(T failedValue)? invalidDateString,
    TResult Function(T failedValue)? invalidCode,
    TResult Function(T failedValue)? invalidEmail,
    TResult Function(T failedValue)? shortPassword,
  }) {
    return invalidCode?.call(failedValue);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(T failedValue)? invalidNftAnswer,
    TResult Function(T failedValue)? invalidUrl,
    TResult Function(T failedValue)? invalidNumberOfImages,
    TResult Function(T failedValue)? invalidUserType,
    TResult Function(T failedValue)? invalidName,
    TResult Function(T failedValue)? invalidDateString,
    TResult Function(T failedValue)? invalidCode,
    TResult Function(T failedValue)? invalidEmail,
    TResult Function(T failedValue)? shortPassword,
    required TResult orElse(),
  }) {
    if (invalidCode != null) {
      return invalidCode(failedValue);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(InvalidNftAnswer<T> value) invalidNftAnswer,
    required TResult Function(InvalidUrl<T> value) invalidUrl,
    required TResult Function(InvalidNumberOfImages<T> value)
        invalidNumberOfImages,
    required TResult Function(InvalidUserType<T> value) invalidUserType,
    required TResult Function(InvalidName<T> value) invalidName,
    required TResult Function(InvalidDateString<T> value) invalidDateString,
    required TResult Function(InvalidCode<T> value) invalidCode,
    required TResult Function(InvalidEmail<T> value) invalidEmail,
    required TResult Function(ShortPassword<T> value) shortPassword,
  }) {
    return invalidCode(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(InvalidNftAnswer<T> value)? invalidNftAnswer,
    TResult Function(InvalidUrl<T> value)? invalidUrl,
    TResult Function(InvalidNumberOfImages<T> value)? invalidNumberOfImages,
    TResult Function(InvalidUserType<T> value)? invalidUserType,
    TResult Function(InvalidName<T> value)? invalidName,
    TResult Function(InvalidDateString<T> value)? invalidDateString,
    TResult Function(InvalidCode<T> value)? invalidCode,
    TResult Function(InvalidEmail<T> value)? invalidEmail,
    TResult Function(ShortPassword<T> value)? shortPassword,
  }) {
    return invalidCode?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(InvalidNftAnswer<T> value)? invalidNftAnswer,
    TResult Function(InvalidUrl<T> value)? invalidUrl,
    TResult Function(InvalidNumberOfImages<T> value)? invalidNumberOfImages,
    TResult Function(InvalidUserType<T> value)? invalidUserType,
    TResult Function(InvalidName<T> value)? invalidName,
    TResult Function(InvalidDateString<T> value)? invalidDateString,
    TResult Function(InvalidCode<T> value)? invalidCode,
    TResult Function(InvalidEmail<T> value)? invalidEmail,
    TResult Function(ShortPassword<T> value)? shortPassword,
    required TResult orElse(),
  }) {
    if (invalidCode != null) {
      return invalidCode(this);
    }
    return orElse();
  }
}

abstract class InvalidCode<T> implements ValueFailure<T> {
  const factory InvalidCode({required T failedValue}) = _$InvalidCode<T>;

  @override
  T get failedValue;
  @override
  @JsonKey(ignore: true)
  $InvalidCodeCopyWith<T, InvalidCode<T>> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $InvalidEmailCopyWith<T, $Res>
    implements $ValueFailureCopyWith<T, $Res> {
  factory $InvalidEmailCopyWith(
          InvalidEmail<T> value, $Res Function(InvalidEmail<T>) then) =
      _$InvalidEmailCopyWithImpl<T, $Res>;
  @override
  $Res call({T failedValue});
}

/// @nodoc
class _$InvalidEmailCopyWithImpl<T, $Res>
    extends _$ValueFailureCopyWithImpl<T, $Res>
    implements $InvalidEmailCopyWith<T, $Res> {
  _$InvalidEmailCopyWithImpl(
      InvalidEmail<T> _value, $Res Function(InvalidEmail<T>) _then)
      : super(_value, (v) => _then(v as InvalidEmail<T>));

  @override
  InvalidEmail<T> get _value => super._value as InvalidEmail<T>;

  @override
  $Res call({
    Object? failedValue = freezed,
  }) {
    return _then(InvalidEmail<T>(
      failedValue: failedValue == freezed
          ? _value.failedValue
          : failedValue // ignore: cast_nullable_to_non_nullable
              as T,
    ));
  }
}

/// @nodoc

class _$InvalidEmail<T> implements InvalidEmail<T> {
  const _$InvalidEmail({required this.failedValue});

  @override
  final T failedValue;

  @override
  String toString() {
    return 'ValueFailure<$T>.invalidEmail(failedValue: $failedValue)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is InvalidEmail<T> &&
            const DeepCollectionEquality()
                .equals(other.failedValue, failedValue));
  }

  @override
  int get hashCode => Object.hash(
      runtimeType, const DeepCollectionEquality().hash(failedValue));

  @JsonKey(ignore: true)
  @override
  $InvalidEmailCopyWith<T, InvalidEmail<T>> get copyWith =>
      _$InvalidEmailCopyWithImpl<T, InvalidEmail<T>>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(T failedValue) invalidNftAnswer,
    required TResult Function(T failedValue) invalidUrl,
    required TResult Function(T failedValue) invalidNumberOfImages,
    required TResult Function(T failedValue) invalidUserType,
    required TResult Function(T failedValue) invalidName,
    required TResult Function(T failedValue) invalidDateString,
    required TResult Function(T failedValue) invalidCode,
    required TResult Function(T failedValue) invalidEmail,
    required TResult Function(T failedValue) shortPassword,
  }) {
    return invalidEmail(failedValue);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function(T failedValue)? invalidNftAnswer,
    TResult Function(T failedValue)? invalidUrl,
    TResult Function(T failedValue)? invalidNumberOfImages,
    TResult Function(T failedValue)? invalidUserType,
    TResult Function(T failedValue)? invalidName,
    TResult Function(T failedValue)? invalidDateString,
    TResult Function(T failedValue)? invalidCode,
    TResult Function(T failedValue)? invalidEmail,
    TResult Function(T failedValue)? shortPassword,
  }) {
    return invalidEmail?.call(failedValue);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(T failedValue)? invalidNftAnswer,
    TResult Function(T failedValue)? invalidUrl,
    TResult Function(T failedValue)? invalidNumberOfImages,
    TResult Function(T failedValue)? invalidUserType,
    TResult Function(T failedValue)? invalidName,
    TResult Function(T failedValue)? invalidDateString,
    TResult Function(T failedValue)? invalidCode,
    TResult Function(T failedValue)? invalidEmail,
    TResult Function(T failedValue)? shortPassword,
    required TResult orElse(),
  }) {
    if (invalidEmail != null) {
      return invalidEmail(failedValue);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(InvalidNftAnswer<T> value) invalidNftAnswer,
    required TResult Function(InvalidUrl<T> value) invalidUrl,
    required TResult Function(InvalidNumberOfImages<T> value)
        invalidNumberOfImages,
    required TResult Function(InvalidUserType<T> value) invalidUserType,
    required TResult Function(InvalidName<T> value) invalidName,
    required TResult Function(InvalidDateString<T> value) invalidDateString,
    required TResult Function(InvalidCode<T> value) invalidCode,
    required TResult Function(InvalidEmail<T> value) invalidEmail,
    required TResult Function(ShortPassword<T> value) shortPassword,
  }) {
    return invalidEmail(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(InvalidNftAnswer<T> value)? invalidNftAnswer,
    TResult Function(InvalidUrl<T> value)? invalidUrl,
    TResult Function(InvalidNumberOfImages<T> value)? invalidNumberOfImages,
    TResult Function(InvalidUserType<T> value)? invalidUserType,
    TResult Function(InvalidName<T> value)? invalidName,
    TResult Function(InvalidDateString<T> value)? invalidDateString,
    TResult Function(InvalidCode<T> value)? invalidCode,
    TResult Function(InvalidEmail<T> value)? invalidEmail,
    TResult Function(ShortPassword<T> value)? shortPassword,
  }) {
    return invalidEmail?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(InvalidNftAnswer<T> value)? invalidNftAnswer,
    TResult Function(InvalidUrl<T> value)? invalidUrl,
    TResult Function(InvalidNumberOfImages<T> value)? invalidNumberOfImages,
    TResult Function(InvalidUserType<T> value)? invalidUserType,
    TResult Function(InvalidName<T> value)? invalidName,
    TResult Function(InvalidDateString<T> value)? invalidDateString,
    TResult Function(InvalidCode<T> value)? invalidCode,
    TResult Function(InvalidEmail<T> value)? invalidEmail,
    TResult Function(ShortPassword<T> value)? shortPassword,
    required TResult orElse(),
  }) {
    if (invalidEmail != null) {
      return invalidEmail(this);
    }
    return orElse();
  }
}

abstract class InvalidEmail<T> implements ValueFailure<T> {
  const factory InvalidEmail({required T failedValue}) = _$InvalidEmail<T>;

  @override
  T get failedValue;
  @override
  @JsonKey(ignore: true)
  $InvalidEmailCopyWith<T, InvalidEmail<T>> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $ShortPasswordCopyWith<T, $Res>
    implements $ValueFailureCopyWith<T, $Res> {
  factory $ShortPasswordCopyWith(
          ShortPassword<T> value, $Res Function(ShortPassword<T>) then) =
      _$ShortPasswordCopyWithImpl<T, $Res>;
  @override
  $Res call({T failedValue});
}

/// @nodoc
class _$ShortPasswordCopyWithImpl<T, $Res>
    extends _$ValueFailureCopyWithImpl<T, $Res>
    implements $ShortPasswordCopyWith<T, $Res> {
  _$ShortPasswordCopyWithImpl(
      ShortPassword<T> _value, $Res Function(ShortPassword<T>) _then)
      : super(_value, (v) => _then(v as ShortPassword<T>));

  @override
  ShortPassword<T> get _value => super._value as ShortPassword<T>;

  @override
  $Res call({
    Object? failedValue = freezed,
  }) {
    return _then(ShortPassword<T>(
      failedValue: failedValue == freezed
          ? _value.failedValue
          : failedValue // ignore: cast_nullable_to_non_nullable
              as T,
    ));
  }
}

/// @nodoc

class _$ShortPassword<T> implements ShortPassword<T> {
  const _$ShortPassword({required this.failedValue});

  @override
  final T failedValue;

  @override
  String toString() {
    return 'ValueFailure<$T>.shortPassword(failedValue: $failedValue)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is ShortPassword<T> &&
            const DeepCollectionEquality()
                .equals(other.failedValue, failedValue));
  }

  @override
  int get hashCode => Object.hash(
      runtimeType, const DeepCollectionEquality().hash(failedValue));

  @JsonKey(ignore: true)
  @override
  $ShortPasswordCopyWith<T, ShortPassword<T>> get copyWith =>
      _$ShortPasswordCopyWithImpl<T, ShortPassword<T>>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(T failedValue) invalidNftAnswer,
    required TResult Function(T failedValue) invalidUrl,
    required TResult Function(T failedValue) invalidNumberOfImages,
    required TResult Function(T failedValue) invalidUserType,
    required TResult Function(T failedValue) invalidName,
    required TResult Function(T failedValue) invalidDateString,
    required TResult Function(T failedValue) invalidCode,
    required TResult Function(T failedValue) invalidEmail,
    required TResult Function(T failedValue) shortPassword,
  }) {
    return shortPassword(failedValue);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function(T failedValue)? invalidNftAnswer,
    TResult Function(T failedValue)? invalidUrl,
    TResult Function(T failedValue)? invalidNumberOfImages,
    TResult Function(T failedValue)? invalidUserType,
    TResult Function(T failedValue)? invalidName,
    TResult Function(T failedValue)? invalidDateString,
    TResult Function(T failedValue)? invalidCode,
    TResult Function(T failedValue)? invalidEmail,
    TResult Function(T failedValue)? shortPassword,
  }) {
    return shortPassword?.call(failedValue);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(T failedValue)? invalidNftAnswer,
    TResult Function(T failedValue)? invalidUrl,
    TResult Function(T failedValue)? invalidNumberOfImages,
    TResult Function(T failedValue)? invalidUserType,
    TResult Function(T failedValue)? invalidName,
    TResult Function(T failedValue)? invalidDateString,
    TResult Function(T failedValue)? invalidCode,
    TResult Function(T failedValue)? invalidEmail,
    TResult Function(T failedValue)? shortPassword,
    required TResult orElse(),
  }) {
    if (shortPassword != null) {
      return shortPassword(failedValue);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(InvalidNftAnswer<T> value) invalidNftAnswer,
    required TResult Function(InvalidUrl<T> value) invalidUrl,
    required TResult Function(InvalidNumberOfImages<T> value)
        invalidNumberOfImages,
    required TResult Function(InvalidUserType<T> value) invalidUserType,
    required TResult Function(InvalidName<T> value) invalidName,
    required TResult Function(InvalidDateString<T> value) invalidDateString,
    required TResult Function(InvalidCode<T> value) invalidCode,
    required TResult Function(InvalidEmail<T> value) invalidEmail,
    required TResult Function(ShortPassword<T> value) shortPassword,
  }) {
    return shortPassword(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(InvalidNftAnswer<T> value)? invalidNftAnswer,
    TResult Function(InvalidUrl<T> value)? invalidUrl,
    TResult Function(InvalidNumberOfImages<T> value)? invalidNumberOfImages,
    TResult Function(InvalidUserType<T> value)? invalidUserType,
    TResult Function(InvalidName<T> value)? invalidName,
    TResult Function(InvalidDateString<T> value)? invalidDateString,
    TResult Function(InvalidCode<T> value)? invalidCode,
    TResult Function(InvalidEmail<T> value)? invalidEmail,
    TResult Function(ShortPassword<T> value)? shortPassword,
  }) {
    return shortPassword?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(InvalidNftAnswer<T> value)? invalidNftAnswer,
    TResult Function(InvalidUrl<T> value)? invalidUrl,
    TResult Function(InvalidNumberOfImages<T> value)? invalidNumberOfImages,
    TResult Function(InvalidUserType<T> value)? invalidUserType,
    TResult Function(InvalidName<T> value)? invalidName,
    TResult Function(InvalidDateString<T> value)? invalidDateString,
    TResult Function(InvalidCode<T> value)? invalidCode,
    TResult Function(InvalidEmail<T> value)? invalidEmail,
    TResult Function(ShortPassword<T> value)? shortPassword,
    required TResult orElse(),
  }) {
    if (shortPassword != null) {
      return shortPassword(this);
    }
    return orElse();
  }
}

abstract class ShortPassword<T> implements ValueFailure<T> {
  const factory ShortPassword({required T failedValue}) = _$ShortPassword<T>;

  @override
  T get failedValue;
  @override
  @JsonKey(ignore: true)
  $ShortPasswordCopyWith<T, ShortPassword<T>> get copyWith =>
      throw _privateConstructorUsedError;
}
